use mysql::*;
use mysql::prelude::*;
use std::sync::mpsc::{Receiver, Sender};
use std::sync::mpsc;
use std::thread;
use std::str;
use std::result::Result;

#[derive(Debug)]
#[derive(PartialEq)]
// struct for the user
pub struct User{
    user_name: String,
    pub public_key: String,
    key_file: String,
    timestamp: u64,
    profile_picture: String,
    info: String,
}

impl User {
    //creates an empty User
    pub fn new() -> Self{
        Self {
            user_name: String::new(),
            public_key: String::new(),
            key_file: String::new(),
            timestamp: 0_u64,
            profile_picture: String::new(),
            info: String::new(),
        }
    }

    pub fn from_tuple(res:&(String, String, String, u64, String, String)) -> Self {
        Self {
            user_name: (*res.0).to_string(),
            public_key: (*res.1).to_string(),
            key_file: (*res.2).to_string(),
            timestamp: res.3,
            profile_picture: (*res.4).to_string(),
            info: (*res.5).to_string(),
        }
    }

    //creates User from argumets passed to the function
    pub fn from(user_name: String, public_key: String, key_file: String, timestamp:u64, profile_picture:String, info:String) -> Self{
        Self {
            user_name: user_name,
            public_key: public_key,
            key_file: key_file,
            timestamp: timestamp,
            profile_picture: profile_picture,
            info: info,
        }
    }

    //creates User from bytes (generated by User.to_bytes())
    pub fn from_bytes(bytes: &Vec<u8>) -> Self {
        //Array with the sizes for each thing that needs to be converted to the User Object, which is stored in the first 8 bytes
        //for the public key and the key_file two u8 need to be converted to a usize
        let sizes:[usize; 6] = [bytes[0] as usize, ((bytes[1] as u16) << 8 | bytes[2] as u16) as usize, ((bytes[3] as u16) << 8 | bytes[4] as u16) as usize, bytes[5] as usize, bytes[6] as usize, bytes[7] as usize];
        //Vec where the String Values are stored
        let mut strings:Vec<&str> = Vec::new();
        let mut timestamp:u64 = 0;

        //This loop coverts the bytes to the values and stores them in their respective variables
        let mut acumulated_size:usize = 8;
        for (i, size) in sizes.iter().enumerate() {
            if i < 3 || i > 3{
                strings.push(str::from_utf8(&bytes[acumulated_size..acumulated_size+size]).unwrap());
            }
            if i == 3{
                //converts 4 u8 to an u64
                timestamp = (bytes[acumulated_size] as u64) << 56 | (bytes[acumulated_size+1] as u64) << 48 | (bytes[acumulated_size+2] as u64) << 40 | (bytes[acumulated_size+3] as u64) << 32 | (bytes[acumulated_size+4] as u64) << 24 | (bytes[acumulated_size+5] as u64) << 16 | (bytes[acumulated_size+6] as u64) << 8 |  bytes[acumulated_size+7] as u64;
            }
            acumulated_size += size;
        }

        Self {
            user_name: String::from(strings[0]),
            public_key: String::from(strings[1]),
            key_file: String::from(strings[2]),
            timestamp: timestamp,
            profile_picture: String::from(strings[3]),
            info: String::from(strings[4]),
        }
    }

    //converts User to a Vec of bytes (Vec<u8>)
    pub fn to_bytes(&self) -> Vec<u8>{
        //the bytes have this form: the first 8 bytes store the sizes of each variable, and next are the bytes for the variables
        //the 1 byte is the size of the username
        //the 2 and 3 are for the public_key
        //the 4 and 5 are for the key_file
        //the 6 is for the timestamp
        //the 7 is for te profile_picture
        //and 8 is for the info
        let mut bytes: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];
        
        //each bloc converts one variable
        //first the variable is converted to bytes
        //then the length is stored in the first 8 bytes, in the way mentioned avove
        //and finaly the bytes are aded to the bytes vector

        let user_name_bytes = self.user_name.bytes();
        bytes[0] = user_name_bytes.len() as u8;
        for byte in user_name_bytes{
            bytes.push(byte);
        }

        let public_key_bytes = self.public_key.bytes();
        bytes[1] = public_key_bytes.len().to_be_bytes()[6];
        bytes[2] = public_key_bytes.len().to_be_bytes()[7];
        for byte in public_key_bytes{
            bytes.push(byte);
        }

        let key_file_bytes = self.key_file.bytes();
        bytes[3] = key_file_bytes.len().to_be_bytes()[6];
        bytes[4] = key_file_bytes.len().to_be_bytes()[7];
        for byte in key_file_bytes{
            bytes.push(byte);
        }

        let timestamp_bytes = self.timestamp.to_be_bytes();
        bytes[5] = timestamp_bytes.len() as u8;
        for byte in timestamp_bytes{
            bytes.push(byte);
        }
        
        let profile_picture_bytes = self.profile_picture.bytes();
        bytes[6] = profile_picture_bytes.len() as u8;
        for byte in profile_picture_bytes{
            bytes.push(byte);
        }

        let info_bytes = self.info.bytes();
        bytes[7] = info_bytes.len() as u8;
        for byte in info_bytes{
            bytes.push(byte);
        }

        bytes
    }
}

#[derive(Debug)]
#[derive(PartialEq)]
//struct for the posts
pub struct Post {
    id: String,
    user_name: String,
    post: String,
    background_color: u8,
    timestamp: u64,
    signature: String
}

impl Post{
    //creates an empty User
    pub fn new() -> Self{
        Self {
            id: String::new(),
            user_name: String::new(),
            post: String::new(),
            background_color: 0_u8,
            timestamp: 0_u64,
            signature: String::new()
        }
    }

    pub fn from_tuple(res:&(String, String, String, u8, u64, String)) -> Self {
        Self {
            id: (*res.0).to_string(),
            user_name: (*res.1).to_string(),
            post: (*res.2).to_string(),
            background_color: res.3,
            timestamp: res.4,
            signature: (*res.5).to_string(),
        }
    }

    pub fn from(id: String, user_name: String, post: String, background_color: u8, timestamp: u64, signature: String) -> Self {
        Self {
            id: id,
            user_name: user_name,
            post: post,
            background_color: background_color,
            timestamp: timestamp,
            signature: signature
        }
    }

    pub fn from_bytes(bytes: &Vec<u8>) -> Self {
        //Vec where the String Values are stored
        let mut strings:Vec<&str> = Vec::new();
        let mut timestamp:u64 = 0;
        let mut background_color:u8 = 0;

        //Array with the sizes for each thing that needs to be converted to the User Object, which is stored in the first 8 bytes
        //for the public key and the key_file two u8 need to be converted to a usize
        let sizes:[usize; 6] = [bytes[0] as usize, bytes[1] as usize, bytes[2] as usize, 1 /*assumed size of background_colour*/, bytes[3] as usize, ((bytes[4] as u16) << 8 | bytes[5] as u16) as usize];

        //This loop coverts the bytes to the values and stores them in their respective variables
        let mut acumulated_size = 6;
        for (i, size) in sizes.iter().enumerate() {
            if i < 3 || i == 5{
                strings.push(str::from_utf8(&bytes[acumulated_size..acumulated_size+size]).unwrap());
            }
            if i == 3{
                background_color = bytes[acumulated_size]
            }
            if i == 4{
                //converts 4 u8 to an u64
                timestamp = (bytes[acumulated_size] as u64) << 56 | (bytes[acumulated_size+1] as u64) << 48 | (bytes[acumulated_size+2] as u64) << 40 | (bytes[acumulated_size+3] as u64) << 32 | (bytes[acumulated_size+4] as u64) << 24 | (bytes[acumulated_size+5] as u64) << 16 | (bytes[acumulated_size+6] as u64) << 8 |  bytes[acumulated_size+7] as u64;
            }
            acumulated_size += size;
        }

        Self {
            id: String::from(strings[0]),
            user_name: String::from(strings[1]),
            post: String::from(strings[2]),
            background_color: background_color,
            timestamp: timestamp,
            signature: String::from(strings[3])
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        //First n bytes determine the lenghth of each variable
        //byte 1 -> id
        //byte 2 -> user_name
        //byte 3 -> post
        //background_color is assumed, as it is alreadu an u8, thus it will always be 1
        //byte 4 -> timestamp
        //bytes 5&6 -> signature
        let mut bytes:Vec<u8> = vec![0, 0, 0, 0, 0, 0];
        
        //each bloc converts one variable
        //first the variable is converted to bytes
        //then the length is stored in the first 8 bytes, in the way mentioned avove
        //and finaly the bytes are aded to the bytes vector
        let id_bytes = self.id.bytes();
        bytes[0] = id_bytes.len() as u8;
        for byte in id_bytes{
            bytes.push(byte);
        }

        let user_name_bytes = self.user_name.bytes();
        bytes[1] = user_name_bytes.len() as u8;
        for byte in user_name_bytes{
            bytes.push(byte);
        }

        let post_bytes = self.post.bytes();
        bytes[2] = post_bytes.len() as u8;
        for byte in post_bytes{
            bytes.push(byte);
        }

        //assumed background color
        bytes.push(self.background_color);

        let timestamp_bytes = self.timestamp.to_be_bytes();
        bytes[3] = timestamp_bytes.len() as u8;
        for byte in timestamp_bytes{
            bytes.push(byte);
        }

        let signature_bytes = self.signature.bytes();
        bytes[4] = signature_bytes.len().to_be_bytes()[6];
        bytes[5] = signature_bytes.len().to_be_bytes()[7];
        for byte in signature_bytes{
            bytes.push(byte);
        }
        
        bytes
    }
}


#[derive(Debug)]
#[derive(PartialEq)]
//struct for the ip
pub struct IP {
    ip: String,
    timestamp: u64 
}

impl IP{
    pub fn new() -> Self {
        Self {
            ip: String::new(),
            timestamp: 0_u64
        }
    }

    pub fn from_tuple(res:&(String, u64)) -> Self {
        Self {
            ip: (*res.0).to_string(),
            timestamp: res.1
        }
    }

    pub fn from(ip:String, timestamp:u64) -> Self {
        Self {
            ip: ip,
            timestamp: timestamp
        }
    }

    pub fn from_bytes(bytes:&Vec<u8>) -> Self {
        let ip = String::from(str::from_utf8(&bytes[2..bytes[0] as usize + 2]).unwrap());
        let timestamp:u64 = (bytes[2+bytes[0] as usize] as u64) << 56 | (bytes[2+bytes[0] as usize+1] as u64) << 48 | (bytes[2+bytes[0] as usize+2] as u64) << 40 | (bytes[2+bytes[0] as usize+3] as u64) << 32 | (bytes[2+bytes[0] as usize+4] as u64) << 24 | (bytes[2+bytes[0] as usize+5] as u64) << 16 | (bytes[2+bytes[0] as usize+6] as u64) << 8 |  bytes[2+bytes[0] as usize+7] as u64;

        Self {
            ip: ip,
            timestamp: timestamp
        }
    } 

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes:Vec<u8> = vec![0, 0];

        let ip_bytes = self.ip.bytes();
        bytes[0] = ip_bytes.len() as u8;
        for byte in ip_bytes{
            bytes.push(byte);
        }
        
        let timestamp_bytes = self.timestamp.to_be_bytes();
        bytes[1] = timestamp_bytes.len() as u8;
        for byte in timestamp_bytes{
            bytes.push(byte);
        }

        bytes
    }

    pub fn get_ip(&self) -> &str {
        &self.ip
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
}


pub struct Database {
    url: String,
    pool: Pool,
    connections: Vec<(Sender<Vec<Vec<u8>>>, Receiver<(QuerryType, String)>)>,
    rx: Receiver<(Sender<Vec<Vec<u8>>>, Receiver<(QuerryType, String)>)>
}

impl Database {
    pub fn init(rx:Receiver<(Sender<Vec<Vec<u8>>>, Receiver<(QuerryType, String)>)>) -> Self{
        let url = String::from("mysql://doxa:[password]@localhost:3306/doxa");
        let pool = Pool::new(url.as_str()).unwrap();
        Self {
            url: url,
            pool: pool,
            connections: Vec::new(),
            rx: rx
        }
    }

    fn connect(&mut self){
        self.pool = Pool::new(self.url.as_str()).unwrap();
    }

    pub fn db_loop(&mut self){
        loop {
            for (tx, rx) in self.connections.iter(){
                let mut return_data:Vec<Vec<u8>> = Vec::new();

                match rx.try_recv() {
                    Ok((return_type, sql)) => {
                        if QuerryType::USER == return_type {
                            println!("user");
                        }
                        return_data = match return_type {
                            QuerryType::USER => macros::querry!(User, (String, String, String, u64, String, String), sql, &self.pool),
                            QuerryType::IP => macros::querry!(IP, (String, u64), sql, &self.pool),
                            QuerryType::POST => macros::querry!(Post, (String, String, String, u8, u64, String), sql, &self.pool),
                            QuerryType::EXECUTE => self.execute(sql),
                        };
                        
                    
                        tx.send(return_data).unwrap();
                    },
                    Err(_) => (),
                };

            }
            match self.rx.try_recv(){
                Ok(pair) => self.connections.push(pair),
                Err(e) => {
                    //println!("{}", e);
                    ()
                },
            };
            //thread::sleep(Duration::from_millis(1000));
        }
    }

    fn execute(&self, sql:String) -> Vec<Vec<u8>> {
        println!("{}", sql);
        let mut conn = self.pool.get_conn().unwrap();

        match conn.exec_drop(sql, ()) {
            Ok(_) => vec![vec![0]],
            Err(e) => {
                println!("{}", e);
                vec![vec![255]]
            }
        }
    }

}

pub fn start_db() -> Sender<(Sender<Vec<Vec<u8>>>, Receiver<(QuerryType, String)>)> {
    let (tx, rx) = mpsc::channel();
    let mut db = Database::init(rx);
    thread::spawn(move || db.db_loop());
    tx
}
#[derive(PartialEq)]
pub enum QuerryType {
    USER,
    POST,
    IP,
    EXECUTE
}

pub mod macros {
    macro_rules! querry {
        ($data_type:ident, $sql_type:ty, $sql:expr, $pool:expr) => {
            {
            let mut datas:Vec<Vec<u8>> = Vec::new();
            let mut conn = $pool.get_conn().unwrap();
            let ress = match conn.exec::<$sql_type, _, _>($sql, ()) {
                Ok(data) => {
                    datas.push(vec![0]);
                    data
                },
                Err(_) => {datas.push(vec![255]); Vec::new()}
            };

            for res in ress.iter(){
                let data = $data_type::from_tuple(res);
                datas.push(data.to_bytes());
            }

            datas
            }
        }

    }
    pub(crate) use querry;
}

pub struct ThreadConnection {
    tx: Sender<(QuerryType, String)>,
    rx: Receiver<Vec<Vec<u8>>>,
}

impl ThreadConnection {
    pub fn new(org_tx:&Sender<(Sender<Vec<Vec<u8>>>, Receiver<(QuerryType, String)>)>) -> Self {
        let (tx, rx1) = mpsc::channel::<(QuerryType, String)>();
        let (tx1, rx) = mpsc::channel::<Vec<Vec<u8>>>();
        org_tx.send((tx1, rx1)).unwrap();
        Self {
            tx: tx,
            rx: rx,
        }
    }
    pub fn querry_users(&self, msg:&str) -> Result<Vec<User>, String> {
        //sends the database thread a querri which returns users (which ir reciebes as bytes), and returns a vector of User (Vec<User>)
        println!("{}", msg);
        self.tx.send((QuerryType::USER, String::from(msg))).unwrap();
        let mut users:Vec<User> = Vec::new();
        let mut data: Vec<Vec<u8>> = self.rx.recv().unwrap();
        if data[0][0] == 255 {
            return Err("Database error".to_string())
        }
        data.remove(0);
        for user_bytes in data.iter() {
            users.push(User::from_bytes(user_bytes));
        }
        Ok(users)
    }

    pub fn querry_posts(&self, msg:&str) -> Result<Vec<Post>, String> {
        //sends the database thread a querri which returns posts (which ir reciebes as bytes), and returns a vector of Post (Vec<Post>)
        self.tx.send((QuerryType::POST, String::from(msg))).unwrap();
        let mut posts:Vec<Post> = Vec::new();
        let mut data: Vec<Vec<u8>> = self.rx.recv().unwrap();
        if data[0][0] == 255 {
            return Err("Database error".to_string())
        }
        data.remove(0);
        for post_bytes in data.iter() {
            posts.push(Post::from_bytes(post_bytes));
        }
        Ok(posts)
    }

    pub fn querry_ips(&self, msg:&str) -> Result<Vec<IP>, String> {
        self.tx.send((QuerryType::IP, String::from(msg))).unwrap();
        let mut ips:Vec<IP> = Vec::new();
        let mut data: Vec<Vec<u8>> = self.rx.recv().unwrap();
        if data[0][0] == 255 {
            return Err("Database error".to_string())
        }
        data.remove(0);
        for ips_bytes in data.iter() {
            ips.push(IP::from_bytes(ips_bytes));
        }
        Ok(ips)
    }

    pub fn execute(&self, msg:&str) -> Result<(), String> {
        self.tx.send((QuerryType::EXECUTE, String::from(msg))).unwrap();
        match self.rx.recv().unwrap()[0][0] {
            255 => Err("ERROR".to_string()),
            _ => Ok(())
        }
    }

    pub fn create(&self) {
        self.tx.send((QuerryType::EXECUTE, String::from("DROP TABLE IF EXISTS posts;"))).unwrap();
        println!("DROPED TABLE 'posts' {:?}", self.rx.recv().unwrap());
        self.tx.send((QuerryType::EXECUTE, String::from("DROP TABLE IF EXISTS users;"))).unwrap();
        println!("DROPED TABLE 'users' {:?}", self.rx.recv().unwrap());

        self.tx.send((QuerryType::EXECUTE, String::from("CREATE TABLE users(user_name VARCHAR(16) COLLATE ascii_general_ci NOT NULL UNIQUE PRIMARY KEY, public_key VARCHAR(44) COLLATE ascii_general_ci NOT NULL UNIQUE, key_file VARCHAR(100) COLLATE ascii_general_ci NOT NULL UNIQUE, timestamp INT NOT NULL, profile_picture VARCHAR(64) COLLATE ascii_general_ci NOT NULL, info VARCHAR(200));"))).unwrap();
        println!("CREATED TABLE 'users' {:?}", self.rx.recv().unwrap());
        self.tx.send((QuerryType::EXECUTE, String::from("CREATE TABLE posts(id VARCHAR(23) NOT NULL PRIMARY KEY, user_name VARCHAR(16) COLLATE ascii_general_ci NOT NULL, post VARCHAR(255) NOT NULL, background_color INT NOT NULL, timestamp INT NOT NULL, signature VARCHAR(88), FOREIGN KEY (user_name) REFERENCES users (user_name));"))).unwrap();
        println!("CREATED TABLE 'posts' {:?}", self.rx.recv().unwrap());

        self.tx.send((QuerryType::EXECUTE, String::from("DROP TABLE IF EXISTS ips;"))).unwrap();
        println!("DROPED TABLE 'ips' {:?}", self.rx.recv().unwrap());

        self.tx.send((QuerryType::EXECUTE, String::from("CREATE TABLE ips(ip VARCHAR(21) NOT NULL PRIMARY KEY, timestamp INT NOT NULL);"))).unwrap();
        println!("CREATED TABLE 'ips' {:?}", self.rx.recv().unwrap());
    }
}
